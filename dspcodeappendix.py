# -*- coding: utf-8 -*-
"""DSPCODEAPPENDIX.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1SfNwWTImhw7JQoqr7f7eV5yUyjomLnAi
"""

import os
import numpy as np
import math
from math import factorial
import sys
from scipy.special import erf, beta, betainc, gamma
from scipy.optimize import brentq
from scipy.integrate import quad
import copy
import time

#######################  Parameters   #################################
random_bands = True                                            ############ Allow for random band thickness

num_sims = 25                                                  ############ Number of simulations

sourcefactor = 0.005
rho = 1.5e12                                                    ############ Dislocation source density

s_sat_factor = 3
h0 = 500
rodrigues_vec = np.array([0.9550, -1.2479, 0.9960])            ############## Rodrigues vector

Gshear = np.array([39.4,39.4,39.4,66.2,66.2,66.2,59.0284,59.0284,59.0284,59.0284,59.0284,59.0284,23.8274,23.8274,23.8274,23.8274,23.8274,23.8274]) * 10**3                         ############## Shear modulus of the slip systems in zinc

num_procs = 1
num_quad = 2

# Number of elements in the x, y and z direction
elX=60
elY=15
elZ=3


# Size of the object (Cuboid objects only)
Lx = 10.48e-6
Ly = 4.42e-6
Lz = 3.17e-6

# Number of Slip Systems
num1 = 3                                                      ############## Number of Basal Planes
num2 = 3                                                      ############## Number of Prismatic Planes
num3 = 6                                                      ############## Number of Pyr. I <a> Planes
num4 = 6                                                      ############## Number of Pyr. II <c+a> Planes
nSlip = num1+num2+num3+num4

# Number of bands in the smallest direction (Lx,Ly,Lz) (thickness of bands follow from this)
numbands = 14
thickness = max(Lx,Ly,Lz)/numbands

# Lattice constants (HCP in this case)
a = 266.46e-12
c = 494.55e-12

################################################################
def odfpoint(r):
    """
    Computes the orientation matrix from a Rodrigues vector.

    Parameters:
    r (numpy.ndarray): Rodrigues vector (1D array of length 3).

    Returns:
    numpy.ndarray: Orientation matrix (3x3).
    """
    # Ensure the input Rodrigues vector is a numpy array
    r = np.array(r)
    dim = len(r)

    # Compute rdotr (dot product of r with itself)
    rdotr = np.dot(r, r)

    # Compute normalization terms
    term1 = 1.0 - rdotr
    term2 = 1.0 + rdotr

    # Initialize the orientation matrix as an identity matrix
    OrientationMatrix = np.eye(dim) * term1

    # Add the symmetric contribution: 2 * r(i) * r(j)
    for i in range(dim):
        for j in range(dim):
            OrientationMatrix[i, j] += 2.0 * r[i] * r[j]

    # Add the skew-symmetric contributions
    OrientationMatrix[0, 1] -= 2.0 * r[2]
    OrientationMatrix[0, 2] += 2.0 * r[1]
    OrientationMatrix[1, 2] -= 2.0 * r[0]
    OrientationMatrix[1, 0] += 2.0 * r[2]
    OrientationMatrix[2, 0] -= 2.0 * r[1]
    OrientationMatrix[2, 1] += 2.0 * r[0]

    # Normalize the matrix by dividing by term2
    OrientationMatrix /= term2

    return OrientationMatrix

#######################################

class distribution:

    def sample(self, nsamples):
        uniform_samples = np.random.rand(nsamples)
        result = np.empty(nsamples, dtype=float)

        for isample in range(nsamples):
            try:
                func = lambda x: self.cdf(x) - uniform_samples[isample]
                result[isample] = brentq(func, self.bracket_a, self.bracket_b)
            except:
                #print(uniform_samples[isample])
                func = lambda x: self.cdf(x) - 0.99
                result[isample] = brentq(func, self.bracket_a, self.bracket_b)

        return result

    @property
    def mean(self):
        func = lambda x: x * self.pdf(x)
        return quad(func, self.bracket_a, self.bracket_b, epsabs=1e-10, epsrel=1e-10)[0]

    @property
    def stdev(self):
        mean = self.mean
        func = lambda x: self.pdf(x)*(x-mean)**2
        return mean, quad(func, self.bracket_a, self.bracket_b, epsabs=1e-10, epsrel=1e-10)[0]**0.5


#################################################


class normal(distribution):

    def __init__(self, mu, sigma):
        super().__init__()
        self.mu = mu
        self.sigma = sigma
        self.bracket_a = mu - 50.0*sigma
        self.bracket_b = mu + 50.0*sigma

        return

    def pdf(self, x):
        return 1.0 / ((2.0*np.pi)**0.5 * self.sigma) * np.exp(-0.5*(x-self.mu)**2 / self.sigma**2)

    def cdf(self, x):
        return 0.5 * (1.0 + erf((x-self.mu) / (self.sigma * 2**0.5)))


####################################

class lognormal(distribution):

    def __init__(self, mu, sigma):
        super().__init__()
        self.mu = mu
        self.sigma = sigma
        self.bracket_a = 0.0
        self.bracket_b = mu + 50.0*sigma
        return

    def pdf(self, x):
        if type(x) is np.ndarray:
            result = np.zeros(x.shape)
            validx = x > 0.0
            result[validx] = 1.0 / (x[validx]*self.sigma*(2*np.pi)**0.5) * np.exp(-(np.log(x[validx]) - self.mu)**2/(2*self.sigma**2))
        elif x > 0.0:
            result = 1.0 / (x*self.sigma*(2*np.pi)**0.5) * np.exp(-(np.log(x) - self.mu)**2/(2*self.sigma**2))
        else:
            result = 0.0
        return result

    def cdf(self, x):
        if type(x) is np.ndarray:
            result = np.zeros(x.shape)
            validx = x > 0.0
            result[validx] = 0.5 + 0.5*erf((np.log(x[validx]) - self.mu)/self.sigma*2**-0.5)
        elif x > 0.0:
            result = 0.5 + 0.5*erf((np.log(x) - self.mu)/self.sigma*2**-0.5)
        else:
            result = 0.0
        return result


####################################
class order(distribution):

    def __init__(self, parent, r, n):
        super().__init__()
        self.parent = parent
        self.r = r
        self.n = n
        self.bracket_a = parent.bracket_a
        self.bracket_b = parent.bracket_b
        return

    def pdf(self, x):
        return 1.0/beta(self.r, self.n-self.r+1) * self.parent.cdf(x)**(self.r-1) \
            * (1.0 - self.parent.cdf(x))**(self.n-self.r) * self.parent.pdf(x)

    def cdf(self, x):
        return betainc(self.r, self.n-self.r+1.0, self.parent.cdf(x))


######################################
class minimum(distribution):

    def __init__(self, parent, n):
        super().__init__()
        self.parent = parent
        self.n = n
        self.bracket_a = parent.bracket_a
        self.bracket_b = parent.bracket_b

    def pdf(self, x):
        return self.n * (1.0 - self.parent.cdf(x))**(self.n-1) * self.parent.pdf(x)

    def cdf(self, x):
        return 1.0 - (1.0 - self.parent.cdf(x))**self.n

######################################
class truncnormal(distribution):

    def __init__(self, mu, sigma, truncf):
        super().__init__()
        self.normal = normal(mu, sigma)
        self.truncf = truncf
        self.bracket_a = mu - truncf*sigma
        self.bracket_b = mu + truncf*sigma

        return

    def pdf(self, x):
        result = self.normal.pdf(x) / (self.normal.cdf(self.bracket_b) - self.normal.cdf(self.bracket_a))
        if type(x) is np.ndarray:
            result[np.logical_or(x < self.bracket_a, x > self.bracket_b)] = 0.0
        elif x < self.bracket_a or x > self.bracket_b:
            result = 0.0
        return result

    def cdf(self, x):
        result = (self.normal.cdf(x) - self.normal.cdf(self.bracket_a)) / (self.normal.cdf(self.bracket_b) - self.normal.cdf(self.bracket_a))
        if type(x) is np.ndarray:
            result[x < self.bracket_a] = 0.0
            result[x > self.bracket_b] = 1.0
        elif x < self.bracket_a:
            result = 0.0
        elif x > self.bracket_b:
            result = 1.0
        return result

######################################
class combine(distribution):

    def __init__(self, parent_a, parent_b, rho_a):
        self.parent_a = parent_a
        self.parent_b = parent_b
        self.rho_a = rho_a
        self.bracket_a = min(parent_a.bracket_a, parent_b.bracket_a)
        self.bracket_b = max(parent_a.bracket_b, parent_b.bracket_b)

        return

    def pdf(self, x):
        return self.rho_a*self.parent_a.pdf(x) + (1.0 - self.rho_a)*self.parent_b.pdf(x)

    def cdf(self, x):
        return self.rho_a*self.parent_a.cdf(x) + (1.0 - self.rho_a)*self.parent_b.cdf(x)



########################################

def gauss_legendre_quad(num_quad):
    """Returns Gauss-Legendre quadrature points and weights for a given num_quad."""
    if num_quad == 2:
        points = np.array([-0.57735027, 0.57735027])
        weights = np.array([1.0, 1.0])
    elif num_quad == 3:
        points = np.array([-0.77459667, 0.0, 0.77459667])
        weights = np.array([5/9, 8/9, 5/9])
    else:
        raise ValueError("num_quad must be 2 or 3")
    return points, weights

def generate_integration_points(num_quad):
    """Generates integration points and weights for a given num_quad in 3D."""
    gauss_points, gauss_weights = gauss_legendre_quad(num_quad)
    xi = np.array([[x, y, z] for z in gauss_points for y in gauss_points for x in gauss_points])
    weights = np.array([wx * wy * wz for wz in gauss_weights for wy in gauss_weights for wx in gauss_weights])
    return xi, weights


########################################

def shape(xi):
    # Shape functions for a 3D hexahedral element (8 nodes)
    N1 = 0.125 * (1 - xi[0]) * (1 - xi[1]) * (1 - xi[2])
    N2 = 0.125 * (1 + xi[0]) * (1 - xi[1]) * (1 - xi[2])
    N3 = 0.125 * (1 + xi[0]) * (1 + xi[1]) * (1 - xi[2])
    N4 = 0.125 * (1 - xi[0]) * (1 + xi[1]) * (1 - xi[2])
    N5 = 0.125 * (1 - xi[0]) * (1 - xi[1]) * (1 + xi[2])
    N6 = 0.125 * (1 + xi[0]) * (1 - xi[1]) * (1 + xi[2])
    N7 = 0.125 * (1 + xi[0]) * (1 + xi[1]) * (1 + xi[2])
    N8 = 0.125 * (1 - xi[0]) * (1 + xi[1]) * (1 + xi[2])

    return np.array([N1, N2, N3, N4, N5, N6, N7, N8])

#########################################

def split_by_3(n):
    """Splits bits of n into every third position for 3D Morton encoding."""
    n &= 0x1fffff  # Limit to 21 bits (p4est safe)
    n = (n | (n << 32)) & 0x1f00000000ffff
    n = (n | (n << 16)) & 0x1f0000ff0000ff
    n = (n | (n << 8))  & 0x100f00f00f00f00f
    n = (n | (n << 4))  & 0x10c30c30c30c30c3
    n = (n | (n << 2))  & 0x1249249249249249
    return n

def morton_3d(x, y, z):
    """Computes the 3D Morton order (Z-order) index for (x, y, z)."""
    return (split_by_3(z) << 2) | (split_by_3(y) << 1) | split_by_3(x)




############################################### Start of the computation ( DO NOT TOUCH !!!!!!) ######################################
# Grid size
nx, ny, nz = elX, elY, elZ  # Adjust as needed
num_cells = nx * ny * nz

# Generate all elements with their (x, y, z) coordinates
elements = []
for x in range(nx):
    for y in range(ny):
        for z in range(nz):
            morton_index = morton_3d(x, y, z)
            elements.append((morton_index, x, y, z))

# Sort elements by Morton index (deal.II ordering)
elements.sort()

# Partitioning for 2 processors using p4est-style distribution
  # Change for more processors
elements_per_proc = num_cells // num_procs
remainder = num_cells % num_procs  # Extra cells that need to be distributed

processor_assignment = []
proc_id = 0
count = 0

for i, (morton_id, x, y, z) in enumerate(elements):
    processor_assignment.append((x, y, z, morton_id, proc_id))
    count += 1

    # Switch processor when reaching the balanced workload
    if proc_id < remainder:  # First `remainder` processors get 1 extra element
        if count >= elements_per_proc + 1:
            proc_id += 1
            count = 0
    else:
        if count >= elements_per_proc:
            proc_id += 1
            count = 0

nodesx = np.linspace(0,Lx,elX+1)
nodesy = np.linspace(0,Ly,elY+1)
nodesz = np.linspace(0,Lz,elZ+1)

nodes = np.empty(((elX+1) * (elY+1) * (elZ+1),3))
nodesnumbers = np.empty((elX*elY*elZ,8),dtype=int)

# Generate the nodal coordinates
nodesx = np.linspace(0, Lx, elX + 1)
nodesy = np.linspace(0, Ly, elY + 1)
nodesz = np.linspace(0, Lz, elZ + 1)

num_cells_per_processor = np.zeros(num_procs)
f = 0
connectivity = np.zeros(elX*elY*elZ,dtype=int)
for m in range(num_procs):
  for i in range(elZ):
    for j in range(elY):
      for k in range(elX):
        for entry in processor_assignment:
          if (entry[0], entry[1], entry[2]) == (k, j, i) and entry[4] == m:

            n0 = k + j*(elX+1) + i*(elX+1)*(elY+1)
            n1 = k + (j+1)*(elX+1) + i *(elX+1)*(elY+1)
            n2 = k + j*(elX+1) + (i+1)*(elX+1)*(elY+1)
            n3 = k + (j+1)*(elX+1) + (i+1) *(elX+1)*(elY+1)

            nodesnumbers[f] = (n0,n0+1,n1+1,n1,n2,n2+1,n3+1,n3)
            connectivity[f] = k + elX*j + elX*elY*i
            f += 1
            num_cells_per_processor[m] += 1

for i in range(elZ+1):
  for j in range(elY+1):
    for k in range(elX+1):
      nodes[k+j*(elX+1)+i*((elX+1)*(elY+1)),0] = nodesx[k]
      nodes[k+j*(elX+1)+i*((elX+1)*(elY+1)),1] = nodesy[j]
      nodes[k+j*(elX+1)+i*((elX+1)*(elY+1)),2] = nodesz[i]




R = odfpoint(rodrigues_vec)                                    ################## Rotation matrix

n0 = np.array([[0,0,1],                                        ################## Normal vectors of the slip systems in hcp crystals
 [0,0,1],
 [0,0,1],
 [-0.866025403784439,-0.5,0],
 [-0.866025403784439,0.5,0],
 [0,1,0],
 [0.784795107517631, 0.453101666584006, 0.422842191550448],
 [-0.784795107517631, -0.453101666584006, 0.422842191550448],
 [-0.784795107517631, 0.453101666584006, 0.422842191550448],
 [0,	-0.906203333168012,	0.422842191550448],
 [0,	0.906203333168012, 0.422842191550448],
 [0.784795107517631, -0.453101666584006, 0.422842191550448],
 [0.440174612804909, 0.762404793580061, 0.474326091384601],
 [0.880349225609819, 0, 0.474326091384601],
 [-0.440174612804909, -0.762404793580061, 0.474326091384601],
 [-0.880349225609819, 0, 0.474326091384601],
 [-0.440174612804909, 0.762404793580061, 0.474326091384601],
 [0.440174612804909, -0.762404793580061, 0.474326091384601]])

b = np.empty(len(n0))
d = np.empty(len(n0))

# Burgers vector
b1 = a
b2 = np.sqrt(a**2+c**2)

# Distance between the planes
d1 = c
d2 = 0.5*np.sqrt(3)*a
d3 = a*c*np.sqrt(3/(4*c**2+3*a**2))
d4 = 2*a*c*np.sqrt(1/(a**2+c**2))

for i in range(num1+num2+num3+num4):
  if i < num1:
    b[i] = b1
    d[i] = d1
  elif i >=num1 and i<(num1+num2):
    b[i] = b1
    d[i] = d2
  elif i >=(num1+num2) and i<(num1+num2+num3):
    b[i] = b2
    d[i] = d3
  else:
    b[i] = b2
    d[i] = d4

xmin, ymin, zmin = nodes[:,0].min(), nodes[:,1].min(), nodes[:,2].min()
xmax, ymax, zmax = nodes[:,0].max(), nodes[:,1].max(), nodes[:,2].max()

n = R.dot(n0.T).T

pmin, pmax = np.empty(3), np.empty(3)

nbands = []
planespb = []
s_obs0 = []

xi, weights = generate_integration_points(num_quad)
s0 = np.empty((len(nodesnumbers),len(xi),len(n)))
ssat = np.empty((len(nodesnumbers),len(xi),len(n)))
h_0 = np.empty((len(nodesnumbers),len(xi),len(n)))
intpointdata =np.empty((len(nodesnumbers),len(xi),len(n)))

seed = np.random.randint(100000, 1000000)
np.random.seed(seed)
rng = np.random.default_rng(seed)

# Calculate integration point coordinates
coords = np.empty((len(nodesnumbers), len(xi), 3))
for ielem, element in enumerate(nodesnumbers):
  for igauss, xi_point in enumerate(xi):
    coords[ielem, igauss] = shape(xi_point).dot(nodes[element])








# Loop to generate x different DSP files
for i in range(1, num_sims+1):
    filename = os.path.join(output_folder, f"DSPinfo_{i}.txt")

    for islip, nslip in enumerate(n):                            ########### nslip is the normal vector for a certain slip system

      pmin[0] = xmin if nslip[0] >= 0.0 else xmax
      pmin[1] = ymin if nslip[1] >= 0.0 else ymax
      pmin[2] = zmin if nslip[2] >= 0.0 else zmax

      pmax[0] = xmax if nslip[0] >= 0.0 else xmin
      pmax[1] = ymax if nslip[1] >= 0.0 else ymin
      pmax[2] = zmax if nslip[2] >= 0.0 else zmin

      distance = np.abs(nslip.dot(pmax - pmin))                       ####### Maximal distance of the object in the direction of the normal vector
      nbands = int(math.ceil(distance/thickness)) + 1                 ####### Number of bands +1 to be on the safe side
      nplanespb = int(round(thickness/d[islip]))                      ####### Planes per band
      nplanes = int(round(distance/d[islip]))                         ####### Total number of planes

      s_nuc_min = Gshear[islip]*b[islip]/(0.5*min(Lx,Ly,Lz))          ####### Minimum yield stress
      s_nuc_max = Gshear[islip]/(2.0*np.pi) * b[islip]/d[islip]       ####### Theoretical maximum yield stress
      std_th = 0.01*(s_nuc_max - s_nuc_min)
      dist_th = truncnormal(s_nuc_max, std_th, 100.0)
      mean_src = 0.5 * (np.log(s_nuc_max) + np.log(s_nuc_min))
      std_src = 1.0/6.0 * (np.log(s_nuc_max) - np.log(s_nuc_min))
      sourcedensity = rho / (0.5*min(Ly,Lz)) / nSlip

      k_0 = h0/distance

      dist_src = lognormal(mean_src, std_src)
      A = Ly*Lz

      chance = sourcedensity * A * d[islip]
      chance = min(chance, 0.999)

      dist = combine(dist_src, dist_th, chance)            ### Make the probability function for the entire gauge

      dist_m = minimum(dist, nplanespb)                    ### Make the probability function for the minimum values

      s_obs0 = dist_m.sample(nbands)                                     ### Sample the distribution for the CRSS


      if random_bands:
        p_rand = rng.random() * thickness * nslip
      else:
        p_rand = np.zeros(3)


      for ielem, (idx, elem) in enumerate(zip(range(len(nodesnumbers)), nodesnumbers)):
        for igauss in range(len(xi)):

          iplane = math.floor(nslip.dot(coords[ielem,igauss] + p_rand - pmin) / thickness)

          intpointdata[idx,igauss,islip] = iplane

          if iplane >= nbands or iplane < 0:
            s0[idx, igauss, islip] =  1.0e99
            ssat[idx, igauss, islip] = 1.0e99
            h_0[idx, igauss, islip] = 0.0

          # Fill in the CRSS, saturation stress and hardening modulus
          else:
            s0[idx, igauss, islip] =  s_obs0[iplane]
            ssat[idx, igauss, islip] = s_sat_factor * s_obs0[iplane]
            h_0[idx, igauss, islip] = thickness * k_0

    # Write output file, only for CRSS in this case
      with open(filename, "w") as f:
        f.write(f"{s0.shape[0]} {s0.shape[1]} {s0.shape[2]}\n")
        for element in s0:
            for gauss in element:
                f.write(" ".join(map(str, gauss)) + "\n")
            f.write("\n")  # Separate Gauss slices with an empty line